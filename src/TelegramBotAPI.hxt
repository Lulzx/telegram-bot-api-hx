/**
* 	This file is auto-generated by TelegramBotAPIExtract.hx
* 	Do not change
**/
package;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.extern.EitherType;
#if cpp
import cpp.vm.Thread;
#elseif java
import java.vm.Thread;
#elseif neko
import neko.vm.Thread;
#end
import haxe.Http;
import haxe.Json;

using TelegramBotAPI;

class TelegramBotAPI {

	private static inline var URL:String = "https://api.telegram.org";
	private static inline var JSON:String = "application/json";
	private static inline var CONTENT_TYPE:String = "Content-Type";

	private var url:String;
	public function new(token:String) url = '$URL/$token/';

	::foreach methods::public function ::name::(::if (params.length > 0)::params:::paramsName::, ::end::?onComplete:Response<::returns::>->Void):Void call(methodName(), ::if (params.length > 0)::params::else::null::end::, onComplete);
	::end::
	private function call<P, T, R:Response<T>>(method:String, params:P = null, onComplete:R -> Void = null):Void {
		var message:Call<P, R> = { method:method, params:params, onComplete:onComplete };
		#if hl
		thread_create(callAsync.bind(message));
		#elseif !macro
		var thread:Thread = Thread.create(callAsync);
		thread.sendMessage(message);
		#end
	}

	#if (hl || macro)
	private function callAsync<P, T, R:Response<T>>(message:Call<P, R>):Void {
	#else
	private function callAsync<P, T, R:Response<T>>():Void {#end
		#if (!hl && !macro) var message:Call<P, Response<T>> = Thread.readMessage(true);#end
		var http:Http = new Http(url + message.method);
		http.addHeader(CONTENT_TYPE, JSON);
		if (message.params != null) http.setPostData(Json.stringify(message.params));
		if (message.onComplete != null) http.onData = http.onError = function(_):Void message.onComplete(Json.parse(http.responseData));
		http.request(true);
	}

	#if idea var $v:Expr; #end
	macro public static function methodName():ExprOf<String> {
		return macro $v{Context.getLocalMethod()};
	}

	#if hl @:hlNative("std","thread_create") static function thread_create( f : Void -> Void ) : hl.Abstract<"hl_thread"> {
		return null;
	}#end
}

typedef Call<P, R> = {
	var method:String;
	var params:P;
	var onComplete:R -> Void;
}

typedef Response<T> = {
	var ok:Bool;
	@:optional var result:T;
	@:optional var error_code:Int;
	@:optional var description:String;
}

/**
*
*	Method params
*
**/

::foreach methods::::if (params.length > 0)::typedef ::paramsName:: = {

	::foreach params::::if optional::@:optional ::end::var ::name:::::type::;
	::end::
}::end::

::end::/**
*
*	Types
*
**/::foreach typeDefs::

typedef ::name:: = {

	::foreach vars::::if optional::@:optional ::end::var ::name:::::type::;
	::end::
}::end::